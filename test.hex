/*

    This case tests self-modifying code.

    Exactly 3 instructions in this test case will be replaced by the
    auxiliary instructions at the bottom of the test case.

    The 3 instructions are:
        1. 83f0 (movl r0, '?')
        2. 83f0 (movl r0, '?')
        3. e011 (jnz r1, r0)

    They get replaced by (respectively):
        1. 8540 (movl r0, 'T')
        2. 8610 (movl r0, 'a')
        3. e001 (jz r1, r0)

    One thing to note is that the 3rd instruction isn't technically
    self-modifying code, since we are replacing the instruction after
    we already executed it. So it should not be in the pipeline when
    it is being modified.

    Instructions 1 and 2 on the other hand, will get replaced by the
    store instructions that comes right before them.

    If self-modifying code is not implemented, you will probably get:

        ?r?nquility

    The expected output is:

        Tranquility

    I hope that by making this test case, it will push people to step
    out of their comfort zones and learn/experiment with something new.

    If you are reading this, I wish you the best of luck with the rest
    of this project. I am sure once you finish this project, you will
    have grown as a person and achieved "Tranquility" in life.

    Good luck, you got this! I believe in you! :)

*/


@0
8081    // movl r1, 0x8
8642    // movl r2, 0x64
f203    // ld r3, r2
f113    // st r3, r1 (Modifies the next instruction, 83f0)
83f0    // movl r0, '?' (Should not execute, gets replaced)
8720    // movl r0, 'r'
8141    // movl r1, 0x14
8662    // movl r2, 0x66
f203    // ld r3, r2
f113    // st r3, r1 (Modifies the next instruction, 83f0)
83f0    // movl r0, '?' (Should not execute, gets replaced)
86e0    // movl r0, 'n'
8710    // movl r0, 'q'
8750    // movl r0, 'u'
8690    // movl r0, 'i'
8301    // movl r1, 0x30
e011    // jnz r1, r0 (Gets replaced)
86c0    // movl r0, 'l'
8201    // movl r1, 0x20
8682    // movl r2, 0x68
f203    // ld r3, r2
f113    // st r3, r1
81c1    // movl r1, 0x1c
e001    // jz r1, r0 (Jumps back to print the 'i' once more)
8740    // movl r0, 't'
8790    // movl r0, 'y'
80a0    // movl r0, '\n'
ffff    // HALT


////////////////////////////
// Auxiliary Instructions //
////////////////////////////
@32     // Byte address 0x64
8540    // movl r0, 'T' (0x64)
8610    // movl r0, 'a' (0x66)
e001    // jz r1, r0 (0x68)